// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3 (swiftlang-1200.0.29.2 clang-1200.0.30.1)
// swift-module-flags: -target i386-apple-ios9.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name CxenseSDK
import AdSupport
import CoreData
import CoreTelephony
@_exported import CxenseSDK
import Darwin
import Foundation
import CoreData.NSManagedObjectContext
import Swift
import SystemConfiguration
import UIKit
import WebKit
final public class SHA1 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA1 : CxenseSDK.Updatable {
  @discardableResult
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
public enum Bit : Swift.Int {
  case zero
  case one
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum PKCS7 {
}
public struct PCBC : CxenseSDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: CxenseSDK.PCBC.Error, b: CxenseSDK.PCBC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: CxenseSDK.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping CxenseSDK.CipherOperationOnBlock) throws -> CxenseSDK.CipherModeWorker
}
extension String {
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func md5() -> Swift.String
  public func sha1() -> Swift.String
  public func sha224() -> Swift.String
  public func sha256() -> Swift.String
  public func sha384() -> Swift.String
  public func sha512() -> Swift.String
  public func sha3(_ variant: CxenseSDK.SHA3.Variant) -> Swift.String
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.String
  public func encrypt(cipher: CxenseSDK.Cipher) throws -> Swift.String
  public func encryptToBase64(cipher: CxenseSDK.Cipher) throws -> Swift.String?
  public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : CxenseSDK.Authenticator
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: CxenseSDK.ChaCha20.Error, b: CxenseSDK.ChaCha20.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension ChaCha20 : CxenseSDK.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension ChaCha20 {
  public struct ChaChaEncryptor : CxenseSDK.Cryptor, CxenseSDK.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension ChaCha20 {
  public struct ChaChaDecryptor : CxenseSDK.Cryptor, CxenseSDK.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension ChaCha20 : CxenseSDK.Cryptors {
  final public func makeEncryptor() -> CxenseSDK.Cryptor & CxenseSDK.Updatable
  final public func makeDecryptor() -> CxenseSDK.Cryptor & CxenseSDK.Updatable
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
@_hasMissingDesignatedInitializers final public class Checksum {
  @objc deinit
}
extension Checksum {
  public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: CxenseSDK.CCM.Error, b: CxenseSDK.CCM.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: CxenseSDK.BlockModeOption
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping CxenseSDK.CipherOperationOnBlock) throws -> CxenseSDK.CipherModeWorker
}
extension Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String?
  public init(base64: Swift.String)
}
@_hasMissingDesignatedInitializers @objc(CXCxense) public class Cxense : ObjectiveC.NSObject {
  @objc public class func trackActiveTime(forEvent name: Swift.String, activeTime: Swift.Int = 0)
  @objc public class func reportEvent(_ event: CxenseSDK.Event)
  @objc public class func reportConversionEvent(_ event: CxenseSDK.Event)
  @objc public class func initialize(withConfiguration config: CxenseSDK.Configuration, _ completion: (() -> Swift.Void)? = nil) throws
  @objc public class func defaultUserId() -> Swift.String
  @objc public class func flushEventQueue()
  @objc public class func queueStatus() -> CxenseSDK.QueueStatus
  @objc deinit
  @objc override dynamic public init()
}
extension Cxense {
  @objc dynamic public class func userProfile(forUserId id: Swift.String, identifierType type: Swift.String, _ groups: [Swift.String]? = nil, _ recent: Swift.Bool, _ identityTypes: [Swift.String]? = nil, _ callback: @escaping (CxenseSDK.DMPUser?, Swift.Error?) -> ())
  @objc dynamic public class func userSegmentIds(forUserIdentifiers userIds: [CxenseSDK.DMPUserIdentifier], andSiteGroupIds siteGroupIds: [Swift.String], _ callback: @escaping (CxenseSDK.DMPSegmentsHolder?, Swift.Error?) -> ())
  @objc dynamic public class func userExternalData(withIdentifierType type: Swift.String, andUserId userId: Swift.String? = nil, _ callback: @escaping ([CxenseSDK.DMPUserData]?, Swift.Error?) -> ())
  @objc dynamic public class func deleteUserExternal(withIdentifierType type: Swift.String, andUserId userId: Swift.String, _ callback: @escaping (Swift.Error?) -> ())
  @objc dynamic public class func userExternalLink(forCxenseId cxId: Swift.String, identifierType: Swift.String, _ callback: @escaping (CxenseSDK.DMPUserIdentifier?, Swift.Error?) -> ())
  @objc dynamic public class func updateUserExternalData(forUserId userId: Swift.String, identifierType type: Swift.String, profiles: [CxenseSDK.DMPExternalProfile], _ callback: @escaping (Swift.Error?) -> ())
  @objc dynamic public class func setUserExternalLink(forUserId userId: Swift.String, identifierType type: Swift.String, cxenseId: Swift.String, _ callback: @escaping (CxenseSDK.DMPUserIdentifier?, Swift.Error?) -> ())
}
extension Cxense {
  @objc dynamic public class func makeWidget(id: Swift.String, context: CxenseSDK.ContentContext, user: CxenseSDK.ContentUser? = nil) -> CxenseSDK.ContentWidget
}
extension Cxense {
  public class func executePersistedQuery<T>(for url: Swift.String, andPersisted persistedQueryId: Swift.String, callback: ((T?, Swift.Error?) -> ())?) where T : Swift.Decodable
  public class func executePersistedQuery<T, V>(for url: Swift.String, andPersisted persistedQueryId: Swift.String, with request: T, callback: ((V?, Swift.Error?) -> ())?) where T : Swift.Encodable, V : Swift.Decodable
}
@available(*, renamed: "Digest")
public typealias Hash = CxenseSDK.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: CxenseSDK.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: CxenseSDK.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
final public class Poly1305 : CxenseSDK.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: CxenseSDK.Poly1305.Error, b: CxenseSDK.Poly1305.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: CxenseSDK.HKDF.Error, b: CxenseSDK.HKDF.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: CxenseSDK.HMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: CxenseSDK.Rabbit.Error, b: CxenseSDK.Rabbit.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension Rabbit : CxenseSDK.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @objc(CXEvent) @objcMembers public class Event : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc public func addParameter(forKey key: Swift.String, withValue value: Any)
  @objc public func getParameter(_ key: Swift.String) -> Any?
  @objc public var rnd: Swift.String? {
    @objc get
    @objc set
  }
  @objc public var name: Swift.String {
    @objc get
    @objc set
  }
  @objc deinit
}
@objc(CXPerformanceEvent) @objcMembers public class PerformanceEvent : CxenseSDK.Event {
  @objc public init(withName name: Swift.String, type: Swift.String, origin: Swift.String, siteId: Swift.String, andUserIds userIds: [CxenseSDK.DMPUserIdentifier])
  @objc public var customParameters: [CxenseSDK.DMPCustomParameter]? {
    @objc get
    @objc set
  }
  @objc public func addCustomParameter(_ param: CxenseSDK.DMPCustomParameter)
  @objc public var segmentIds: [Swift.String]? {
    @objc get
    @objc set
  }
  @objc public var type: Swift.String {
    @objc get
    @objc set
  }
  @objc public var origin: Swift.String {
    @objc get
    @objc set
  }
  @objc public var siteId: Swift.String {
    @objc get
    @objc set
  }
  @objc public var prnd: Swift.String? {
    @objc get
    @objc set
  }
  public var eventId: Swift.Int? {
    get
    set
  }
  public var pageViewEventId: Swift.Int? {
    get
    set
  }
  public var time: Foundation.TimeInterval? {
    get
    set
  }
  @objc public var userIds: [CxenseSDK.DMPUserIdentifier] {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic public init()
}
@objc(CXPageViewEvent) @objcMembers public class PageViewEvent : CxenseSDK.Event {
  @objc public init(withName name: Swift.String)
  @objc public var persistentCookie: Swift.String {
    @objc get
    @objc set
  }
  @objc public var location: Swift.String? {
    @objc get
    @objc set
  }
  @objc public var contentId: Swift.String? {
    @objc get
    @objc set
  }
  @objc public var referrer: Swift.String? {
    @objc get
    @objc set
  }
  @objc public var siteId: Swift.String? {
    @objc get
    @objc set
  }
  @objc public var type: Swift.String {
    @objc get
    @objc set
  }
  @objc public var apiVersion: Swift.String {
    @objc get
    @objc set
  }
  @objc public func addExternalUserId(_ id: Swift.String, withType userType: Swift.String)
  @objc public func clearExternalUserIds()
  @objc public func addCustomParameter(forKey key: Swift.String, withValue value: Swift.String)
  @objc public func getCustomParameter(forKey key: Swift.String) -> Swift.String?
  @objc public func addUserProfileParameter(forKey key: Swift.String, withValue value: Swift.String)
  @objc public func getUserProfileParameter(forKey key: Swift.String) -> Swift.String?
  @objc deinit
  @objc override dynamic public init()
}
extension Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: CxenseSDK.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: CxenseSDK.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: CxenseSDK.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: CxenseSDK.Authenticator) throws -> Foundation.Data
}
extension Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
public struct CFB : CxenseSDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: CxenseSDK.CFB.Error, b: CxenseSDK.CFB.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: CxenseSDK.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping CxenseSDK.CipherOperationOnBlock) throws -> CxenseSDK.CipherModeWorker
}
final public class GCM : CxenseSDK.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: CxenseSDK.GCM.Mode, b: CxenseSDK.GCM.Mode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let options: CxenseSDK.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: CxenseSDK.GCM.Error, b: CxenseSDK.GCM.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: CxenseSDK.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: CxenseSDK.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping CxenseSDK.CipherOperationOnBlock) throws -> CxenseSDK.CipherModeWorker
  @objc deinit
}
extension HMAC {
  convenience public init(key: Swift.String, variant: CxenseSDK.HMAC.Variant = .md5) throws
}
public typealias CipherOperationOnBlock = (Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: CxenseSDK.BlockModeOption { get }
  func worker(blockSize: Swift.Int, cipherOperation: @escaping CxenseSDK.CipherOperationOnBlock) throws -> CxenseSDK.CipherModeWorker
}
extension PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: CxenseSDK.PKCS5.PBKDF2.Error, b: CxenseSDK.PKCS5.PBKDF2.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: CxenseSDK.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
final public class HMAC : CxenseSDK.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: CxenseSDK.HMAC.Error, b: CxenseSDK.HMAC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: CxenseSDK.HMAC.Variant, b: CxenseSDK.HMAC.Variant) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: CxenseSDK.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: CxenseSDK.Padding = .pkcs7) throws
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: CxenseSDK.AES.Error, b: CxenseSDK.AES.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: CxenseSDK.AES.Variant
  public init(key: Swift.Array<Swift.UInt8>, blockMode: CxenseSDK.BlockMode, padding: CxenseSDK.Padding = .pkcs7) throws
  @objc deinit
}
extension AES : CxenseSDK.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: CxenseSDK.CTR.Error, b: CxenseSDK.CTR.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: CxenseSDK.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping CxenseSDK.CipherOperationOnBlock) throws -> CxenseSDK.CipherModeWorker
}
public struct ECB : CxenseSDK.BlockMode {
  public let options: CxenseSDK.BlockModeOption
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping CxenseSDK.CipherOperationOnBlock) throws -> CxenseSDK.CipherModeWorker
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: CxenseSDK.Blowfish.Error, b: CxenseSDK.Blowfish.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: CxenseSDK.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: CxenseSDK.Padding) throws
  @objc deinit
}
extension Blowfish : CxenseSDK.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public protocol CipherModeWorker {
  var cipherOperation: CxenseSDK.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : CxenseSDK.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : CxenseSDK.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : CxenseSDK.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : CxenseSDK.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : CxenseSDK.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : CxenseSDK.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
extension Array {
  public init(reserveCapacity: Swift.Int)
}
extension Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: CxenseSDK.SHA2.Variant) -> [Element]
  public func sha3(_ variant: CxenseSDK.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: CxenseSDK.Cipher) throws -> [Element]
  public func decrypt(cipher: CxenseSDK.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : CxenseSDK.Authenticator
}
public struct OFB : CxenseSDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: CxenseSDK.OFB.Error, b: CxenseSDK.OFB.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: CxenseSDK.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping CxenseSDK.CipherOperationOnBlock) throws -> CxenseSDK.CipherModeWorker
}
extension Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: CxenseSDK.Padding = .pkcs7) throws
}
@_inheritsConvenienceInitializers final public class CMAC : CxenseSDK.CBCMAC {
  @objc deinit
  override public init(key: Swift.Array<Swift.UInt8>) throws
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: CxenseSDK.CipherError, b: CxenseSDK.CipherError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension AES : CxenseSDK.Cryptors {
  final public func makeEncryptor() throws -> CxenseSDK.Cryptor & CxenseSDK.Updatable
  final public func makeDecryptor() throws -> CxenseSDK.Cryptor & CxenseSDK.Updatable
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : CxenseSDK.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
public enum ConfigurationError : Swift.Error {
  case tooSmallOutdatedTimeout
  case tooShortDispatchInterval
  @available(*, deprecated, message: "Item will be removed in next versions.")
  case invalidApiKey
  @available(*, deprecated, message: "Item will be removed in next versions.")
  case invalidUserName
  public static func == (a: CxenseSDK.ConfigurationError, b: CxenseSDK.ConfigurationError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers @objc public class ServerError : ObjectiveC.NSObject, Swift.Codable, Swift.Error {
  public var error: Swift.String {
    get
  }
  public var responseStatusCode: Swift.Int? {
    get
  }
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(CXDispatchMode) public enum DispatchMode : Swift.Int {
  case offline
  case online
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc(CXNetworkRestriction) public enum NetworkRestriction : Swift.Int {
  case none = -1
  case gprs = 0
  case mobile = 1
  case wifi = 2
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
  public init?(rawValue: Swift.Int)
}
@objc(CXConsentOption) public enum ConsentOptions : Swift.Int {
  case consentRequired
  case pvAllowed
  case recsAllowed
  case segmentAllowed
  case adAllowed
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @objc(CXConfiguration) @objcMembers public class Configuration : ObjectiveC.NSObject {
  @objc public var userName: Swift.String
  @objc public var apiKey: Swift.String
  @objc public var dispatchInterval: Foundation.TimeInterval
  @objc public var outdatedTimeout: Foundation.TimeInterval
  @objc public var networkRestriction: CxenseSDK.NetworkRestriction
  @objc public var dispatchMode: CxenseSDK.DispatchMode
  @objc public var dmpPushPersistentId: Swift.String?
  @objc public var userAgent: Swift.String {
    @objc get
    @objc set
  }
  @objc public var autoMetaInfTrackingEnabled: Swift.Bool
  @objc public var eventsCallback: ((Swift.String, Swift.Bool, Swift.Error?) -> ())?
  public var consentOptions: [CxenseSDK.ConsentOptions]?
  @objc public init(withUserName userName: Swift.String, apiKey: Swift.String)
  @objc convenience override dynamic public init()
  @objc deinit
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension MD5 : CxenseSDK.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : CxenseSDK.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: CxenseSDK.Padding, b: CxenseSDK.Padding) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> CxenseSDK.Cryptor & CxenseSDK.Updatable
  func makeDecryptor() throws -> CxenseSDK.Cryptor & CxenseSDK.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension Cryptors {
  public static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: CxenseSDK.PKCS5.PBKDF1.Error, b: CxenseSDK.PKCS5.PBKDF1.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public enum Variant {
      case md5, sha1
      public static func == (a: CxenseSDK.PKCS5.PBKDF1.Variant, b: CxenseSDK.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: CxenseSDK.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    public func calculate() -> Swift.Array<Swift.UInt8>
  }
}
public struct CBC : CxenseSDK.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: CxenseSDK.CBC.Error, b: CxenseSDK.CBC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: CxenseSDK.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping CxenseSDK.CipherOperationOnBlock) throws -> CxenseSDK.CipherModeWorker
}
final public class SHA2 {
  public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: CxenseSDK.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: CxenseSDK.SHA2.Variant.RawValue)
  }
  public init(variant: CxenseSDK.SHA2.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA2 : CxenseSDK.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public enum PKCS5 {
}
public enum IncorrectConfiguration : Swift.Error {
  case valueRequired(cause: Swift.String)
  case invalidParameter(cause: Swift.String, recommendation: Swift.String)
  case conflictingParameters(cause: Swift.String, recommendation: Swift.String)
}
public protocol EventBuilder {
  associatedtype EventType
  func build() throws -> Self.EventType
}
@objc @_hasMissingDesignatedInitializers @objcMembers public class BaseEventBuilder : ObjectiveC.NSObject {
  @objc public func setRnd(_ eventRnd: Swift.String) -> Self
  @objc public func addParameter(forKey key: Swift.String, withValue value: Any) -> Self
  @objc deinit
  @objc override dynamic public init()
}
@_hasMissingDesignatedInitializers @objc(CXPageViewEventBuilder) @objcMembers public class PageViewEventBuilder : CxenseSDK.BaseEventBuilder {
  @objc public func addUserProfileParameter(forKey key: Swift.String, withValue value: Swift.String) -> Self
  @objc public func addCustomParameter(forKey key: Swift.String, withValue value: Swift.String) -> Self
  @objc public func addExternalUserId(_ id: Swift.String, withType userType: Swift.String) -> Self
  @objc(setLocation:) public func setLocation(loc: Swift.String) -> Self
  @objc(setReferrer:) public func setReferrer(ref: Swift.String) -> Self
  @objc(setContentId:) public func setContentId(cid: Swift.String) -> Self
  @objc(setPersistentCookie:) public func setPersistentCookie(ckp: Swift.String) -> Self
  @objc public class func makeBuilder(withName name: Swift.String, siteId: Swift.String) -> CxenseSDK.PageViewEventBuilder
  @objc deinit
}
extension PageViewEventBuilder : CxenseSDK.EventBuilder {
  @objc(build:) dynamic public func build() throws -> CxenseSDK.PageViewEvent
  public typealias EventType = CxenseSDK.PageViewEvent
}
@_hasMissingDesignatedInitializers @objc(CXPerformanceEventBuilder) @objcMembers public class PerformanceEventBuilder : CxenseSDK.BaseEventBuilder {
  @objc public func setTime(_ interval: Foundation.TimeInterval) -> Self
  @objc public func setEventId(_ eid: Swift.Int) -> Self
  @objc public func setPageViewEventId(_ pvId: Swift.Int) -> Self
  @objc public func setPrnd(_ pvId: Swift.String) -> Self
  @objc public func setSegmentIds(_ ids: [Swift.String]) -> Self
  @objc public func addSegmentId(_ segmentId: Swift.String) -> Self
  @objc public func addCustomParameter(_ param: CxenseSDK.DMPCustomParameter) -> Self
  @objc public class func makeBuilder(withName name: Swift.String, type: Swift.String, origin: Swift.String, siteId: Swift.String, andUserIds uids: [CxenseSDK.DMPUserIdentifier]) -> CxenseSDK.PerformanceEventBuilder
  @objc deinit
}
extension PerformanceEventBuilder : CxenseSDK.EventBuilder {
  @objc(build:) dynamic public func build() throws -> CxenseSDK.PerformanceEvent
  public typealias EventType = CxenseSDK.PerformanceEvent
}
@_hasMissingDesignatedInitializers @objc(CXConversionEventBuilder) @objcMembers public class ConversionEventBuilder : CxenseSDK.BaseEventBuilder {
  @objc public func setTime(_ interval: Foundation.TimeInterval) -> Self
  @objc public func setEventId(_ eid: Swift.Int) -> Self
  @objc public func setPageViewEventId(_ pvId: Swift.Int) -> Self
  @objc public func setPrnd(_ pvId: Swift.String) -> Self
  @objc public func setSegmentIds(_ ids: [Swift.String]) -> Self
  @objc public func addSegmentId(_ segmentId: Swift.String) -> Self
  @objc public func addCustomParameter(_ param: CxenseSDK.DMPCustomParameter) -> Self
  @objc public class func makeBuilder(withName name: Swift.String, type: Swift.String, origin: Swift.String, siteId: Swift.String, andUserIds uids: [CxenseSDK.DMPUserIdentifier]) -> CxenseSDK.ConversionEventBuilder
  @objc deinit
}
extension ConversionEventBuilder : CxenseSDK.EventBuilder {
  @objc(build:) dynamic public func build() throws -> CxenseSDK.PerformanceEvent
  public typealias EventType = CxenseSDK.PerformanceEvent
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension Updatable {
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish() throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
public protocol _UInt8Type {
}
extension UInt8 : CxenseSDK._UInt8Type {
}
extension UInt8 {
  public func bits() -> [CxenseSDK.Bit]
  public func bits() -> Swift.String
}
extension String {
  public func decryptBase64ToString(cipher: CxenseSDK.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: CxenseSDK.Cipher) throws -> Swift.Array<Swift.UInt8>
}
@objc(CXDmpSegmentsHolder) @objcMembers public class DMPSegmentsHolder : ObjectiveC.NSObject, Swift.Codable {
  @objc public var segments: [Swift.String]?
  @objc public init(segments: [Swift.String] = [])
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(CXDmpGroup) @objcMembers public class DMPGroup : ObjectiveC.NSObject, Swift.Codable {
  @objc public var group: Swift.String
  @objc public var count: Swift.Int
  @objc public var weight: Swift.Float
  @objc public init(group: Swift.String = "", count: Swift.Int = 0, weight: Swift.Float = 0.0)
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(CXDmpUserData) @objcMembers public class DMPUserData : ObjectiveC.NSObject, Swift.Codable {
  @objc public var id: Swift.String
  @objc public var type: Swift.String
  @objc public var profiles: [CxenseSDK.DMPExternalProfile]
  @objc public init(id: Swift.String, type: Swift.String, profiles: [CxenseSDK.DMPExternalProfile] = [])
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(CXDmpExternalProfile) @objcMembers public class DMPExternalProfile : ObjectiveC.NSObject, Swift.Codable {
  @objc public var group: Swift.String
  @objc public var item: Swift.String
  @objc public init(group: Swift.String, item: Swift.String)
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(CXDmpProfile) @objcMembers public class DMPProfile : ObjectiveC.NSObject, Swift.Codable {
  @objc public var groups: [CxenseSDK.DMPGroup]
  @objc public var item: Swift.String
  @objc public init(groups: [CxenseSDK.DMPGroup] = [], item: Swift.String = "")
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(CXDmpUserIdentifier) @objcMembers public class DMPUserIdentifier : ObjectiveC.NSObject, Swift.Codable {
  @objc public var type: Swift.String
  @objc public var identifier: Swift.String
  @objc public init(identifier: Swift.String, type: Swift.String)
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers @objc(CXDmpUser) @objcMembers public class DMPUser : ObjectiveC.NSObject, Swift.Codable {
  @objc public var userId: Swift.String
  @objc public var userType: Swift.String
  @objc public var profiles: [CxenseSDK.DMPProfile]
  @objc public var identities: [Swift.String]?
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(CXDmpCustomParameter) @objcMembers public class DMPCustomParameter : ObjectiveC.NSObject, Swift.Codable {
  @objc required public init(group: Swift.String, item: Swift.String, type: Swift.String? = nil)
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(CXCceCustomParameter) @objcMembers public class CCECustomParameter : ObjectiveC.NSObject, Swift.Codable {
  @objc required public init(group: Swift.String, item: Swift.String, type: Swift.String? = nil)
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(CXContentUser) @objcMembers public class ContentUser : ObjectiveC.NSObject, Swift.Codable {
  @objc public var ids: [Swift.String : Swift.String]
  @objc public var likes: [Swift.String]?
  @objc public var dislikes: [Swift.String]?
  @objc public init(withIds ids: [Swift.String : Swift.String], likes: [Swift.String]? = nil, dislikes: [Swift.String]? = nil)
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers @objc(CXContentRecommendation) @objcMembers public class ContentRecommendation : ObjectiveC.NSObject {
  @objc public var url: Swift.String
  @objc public var clickUrl: Swift.String
  @objc public var title: Swift.String
  @objc public var data: [Swift.String : Any]?
  @objc public var dominantthumbnail: Swift.String?
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(CXContentContext) @objcMembers public class ContentContext : ObjectiveC.NSObject, Swift.Codable {
  @objc public var url: Swift.String?
  @objc public var pageclass: Swift.String?
  @objc public var sentiment: Swift.String?
  @objc public var recommending: Swift.Bool
  @objc public var categories: [Swift.String : Swift.String]?
  @objc public var parameters: [[Swift.String : Swift.String]]?
  @objc public var keywords: [Swift.String]?
  @objc public var neighbors: [Swift.String]?
  @objc public var referrer: Swift.String?
  @objc public func addParameter(_ key: Swift.String, _ value: Swift.String)
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc(CXContentWidget) @objcMembers public class ContentWidget : ObjectiveC.NSObject, Swift.Codable {
  @objc public var widgetId: Swift.String
  @objc public var context: CxenseSDK.ContentContext?
  @objc public var user: CxenseSDK.ContentUser?
  @objc public var consent: [Swift.String]?
  @objc public init(id: Swift.String, context: CxenseSDK.ContentContext? = nil, user: CxenseSDK.ContentUser? = nil, consent: [Swift.String]? = nil)
  @objc public func trackClick(for reco: CxenseSDK.ContentRecommendation)
  @objc public func fetchItems(withCallback callback: @escaping ([CxenseSDK.ContentRecommendation]?, Swift.Error?) -> ())
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers @objc(CXQueueStatus) @objcMembers public class QueueStatus : ObjectiveC.NSObject {
  @objc final public let sentEvents: Swift.Set<Swift.String>
  @objc final public let notSentEvents: Swift.Set<Swift.String>
  @objc override dynamic public init()
  @objc deinit
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public typealias Element = CxenseSDK.BlockModeOption
  public typealias ArrayLiteralElement = CxenseSDK.BlockModeOption
  public typealias RawValue = Swift.Int
}
public class CBCMAC : CxenseSDK.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: CxenseSDK.CBCMAC.Error, b: CxenseSDK.CBCMAC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: CxenseSDK.SHA3.Variant, b: CxenseSDK.SHA3.Variant) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(variant: CxenseSDK.SHA3.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA3 : CxenseSDK.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
@_hasMissingDesignatedInitializers public class BlockDecryptor : CxenseSDK.Cryptor, CxenseSDK.Updatable {
  public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
extension CxenseSDK.Bit : Swift.Equatable {}
extension CxenseSDK.Bit : Swift.Hashable {}
extension CxenseSDK.Bit : Swift.RawRepresentable {}
extension CxenseSDK.PCBC.Error : Swift.Equatable {}
extension CxenseSDK.PCBC.Error : Swift.Hashable {}
extension CxenseSDK.ChaCha20.Error : Swift.Equatable {}
extension CxenseSDK.ChaCha20.Error : Swift.Hashable {}
extension CxenseSDK.CCM : CxenseSDK.BlockMode {}
extension CxenseSDK.CCM.Error : Swift.Equatable {}
extension CxenseSDK.CCM.Error : Swift.Hashable {}
extension CxenseSDK.Poly1305.Error : Swift.Equatable {}
extension CxenseSDK.Poly1305.Error : Swift.Hashable {}
extension CxenseSDK.HKDF.Error : Swift.Equatable {}
extension CxenseSDK.HKDF.Error : Swift.Hashable {}
extension CxenseSDK.Rabbit.Error : Swift.Equatable {}
extension CxenseSDK.Rabbit.Error : Swift.Hashable {}
extension CxenseSDK.CFB.Error : Swift.Equatable {}
extension CxenseSDK.CFB.Error : Swift.Hashable {}
extension CxenseSDK.GCM.Mode : Swift.Equatable {}
extension CxenseSDK.GCM.Mode : Swift.Hashable {}
extension CxenseSDK.GCM.Error : Swift.Equatable {}
extension CxenseSDK.GCM.Error : Swift.Hashable {}
extension CxenseSDK.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension CxenseSDK.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension CxenseSDK.HMAC.Error : Swift.Equatable {}
extension CxenseSDK.HMAC.Error : Swift.Hashable {}
extension CxenseSDK.HMAC.Variant : Swift.Equatable {}
extension CxenseSDK.HMAC.Variant : Swift.Hashable {}
extension CxenseSDK.AES.Error : Swift.Equatable {}
extension CxenseSDK.AES.Error : Swift.Hashable {}
extension CxenseSDK.AES.Variant : Swift.Equatable {}
extension CxenseSDK.AES.Variant : Swift.Hashable {}
extension CxenseSDK.AES.Variant : Swift.RawRepresentable {}
extension CxenseSDK.CTR : CxenseSDK.BlockMode {}
extension CxenseSDK.CTR.Error : Swift.Equatable {}
extension CxenseSDK.CTR.Error : Swift.Hashable {}
extension CxenseSDK.Blowfish.Error : Swift.Equatable {}
extension CxenseSDK.Blowfish.Error : Swift.Hashable {}
extension CxenseSDK.OFB.Error : Swift.Equatable {}
extension CxenseSDK.OFB.Error : Swift.Hashable {}
extension CxenseSDK.CipherError : Swift.Equatable {}
extension CxenseSDK.CipherError : Swift.Hashable {}
extension CxenseSDK.ConfigurationError : Swift.Equatable {}
extension CxenseSDK.ConfigurationError : Swift.Hashable {}
extension CxenseSDK.DispatchMode : Swift.Equatable {}
extension CxenseSDK.DispatchMode : Swift.Hashable {}
extension CxenseSDK.DispatchMode : Swift.RawRepresentable {}
extension CxenseSDK.NetworkRestriction : Swift.Equatable {}
extension CxenseSDK.NetworkRestriction : Swift.Hashable {}
extension CxenseSDK.NetworkRestriction : Swift.RawRepresentable {}
extension CxenseSDK.ConsentOptions : Swift.Equatable {}
extension CxenseSDK.ConsentOptions : Swift.Hashable {}
extension CxenseSDK.ConsentOptions : Swift.RawRepresentable {}
extension CxenseSDK.Padding : Swift.Equatable {}
extension CxenseSDK.Padding : Swift.Hashable {}
extension CxenseSDK.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension CxenseSDK.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension CxenseSDK.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension CxenseSDK.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension CxenseSDK.CBC.Error : Swift.Equatable {}
extension CxenseSDK.CBC.Error : Swift.Hashable {}
extension CxenseSDK.SHA2.Variant : Swift.Equatable {}
extension CxenseSDK.SHA2.Variant : Swift.Hashable {}
extension CxenseSDK.CBCMAC.Error : Swift.Equatable {}
extension CxenseSDK.CBCMAC.Error : Swift.Hashable {}
extension CxenseSDK.SHA3.Variant : Swift.Equatable {}
extension CxenseSDK.SHA3.Variant : Swift.Hashable {}
